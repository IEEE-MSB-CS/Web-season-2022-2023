## Table of Contents

- [ ] This, call, bind, apply
- [ ] Prototypical inheritance
- [ ] Arrow functions
- [ ] Call, Bind, Apply
- [x] Execution Context and it's phases
- [ ] Closures
- [x] Scope chain
- [ ] Callbacks, Promises, Async await
- [ ] Hoisting
- [ ] Event Loop
- [ ] Javascript Engine
- [ ] Javascript Runtime
- [ ] Interpreter, Compiler, JIT Compiler
- [ ] Writing Optimized Code
- [x] Call Stack + Memory Heap
- [ ] Stack Overflow + Memory Leaks
- [ ] Garbage Collection
- [ ] ES6, ES7, ES8, ES9 features
- [ ] Single Threaded Model
- [ ] Lexical Environment
- [x] Hoisting
- [ ] Function Invocation
- [x] Function Scope vs Block Scope
- [ ] Dynamic vs Lexical Scope
- [ ] this â€“ call(), apply(), bind()
- [ ] IIFEs
- [ ] Static vs Dynamically Typed
- [ ] Primitive Types
- [ ] Pass by Reference vs Pass by Value
- [ ] Type Coercion
- [ ] Arrays, Functions, Objects
- [ ] Closures
- [ ] Prototypal Inheritance
- [ ] Class Inheritance
- [ ] Memoization
- [ ] Higher Order Functions
- [ ] Functions vs Objects
- [ ] Scheme + Java in JavaScript
- [ ] OOP (Object Oriented Programming)
- [ ] Private vs Public properties
- [ ] Immutability
- [ ] Imperative vs Declarative code
- [ ] Composition vs Inheritance
- [ ] Currying
- [ ] Partial Application
- [ ] Pure Functions
- [ ] Referential Transparency
- [ ] Compose
- [ ] Pipe
- [ ] Error Handling
- [ ] Asynchronous JavaScript
- [ ] Callbacks, Promises, AsyncAwait
- [ ] Event Loop + Callback Queue
- [ ] Task Queue + Microtask Queue
- [ ] Concurrency + Parallelism
- [ ] Modules in Javascript
- [ ] Throttling and Debouncing
- [ ] Iterables
- [ ] Create Your Own Arrays

## Resources
